# Define the Home Assistant devices that we will be using to retreive remote
# temperature readings.  Currently a remote temp sensor is required mostly due
# to the fact that the iSee sensor in the Mitsubishi unit is incredibly inaccurate.
# The original Kumo cloud implementation deployed with bluetooth temp/humidity
# sensors which dramatically improved things.
#
# This package provides for a dual sensor configuration in which one of the sensors
# is the primary and the other the backup.  In certain situations not all sensors
# read as accurately and thus you might prefer one over the other.  In addition 
# we want to guard against no reading (battery devices, etc.) thus a desire to have
# two (2) devices in a primary/backup configuration.
#
# This package requires the following substitutions to be defined:
#
#    rts_primary_sensor --> The HA ID of the sensor to be used as the primary
#    rts_backup_sensor  --> The HA ID of the sensor to be used as the backup
#    rts_average_value  --> Boolean indicating if we should average (default) or use primary/backup
#
substitutions:
    rts_average_value: 1   # Default is to average the values from the two sensors
    
sensor:
  # Primary Temperature Sensor
  - platform: homeassistant
    name: "Master Bedroom Zigbee Temperature Sensor"
    id: rts_primary_sensor
    entity_id: ${rts_primary_sensor}
    internal: true
    disabled_by_default: true
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    filters:
      # We currently use Celcius for internal temp management
      - lambda: return (x - 32) * (5.0/9.0);
      - clamp: # Limits values to range accepted by Mitsubishi units
          min_value: 1
          max_value: 40
          ignore_out_of_range: true
      - throttle: 5s
    on_value:
      then:
        - script.execute: reevaluate_remote_temp
            
  #
  # Retrieve the additional sensor data that we will use as a backup in case the 
  # primary sensor is not functioning.  This sensor tends to be impacted a bit by
  # the airflow from the split mini resulting in slightly incorrect values.
  #
  - platform: homeassistant
    entity_id: ${rts_backup_sensor}
    id: rts_backup_sensor
    name: "Master Bedroom Z-Wave Temperature Sensor"
    internal: true
    disabled_by_default: false
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    filters:
      # We currently use Celcius for internal temp management
      - lambda: return (x - 32) * (5.0/9.0);
      - clamp: # Limits values to range accepted by Mitsubishi units
          min_value: 1
          max_value: 40
          ignore_out_of_range: true
      - throttle: 5s
    on_value:
      then:
        - script.execute: reevaluate_remote_temp

script:
  # Helper script called when the climate mode changes.
  - id: climate_mode_changed
    then:
      - lambda: |-
          ESP_LOGI("main", "Climate mode change: %d", id(${hp_id}).mode);
      - script.execute: reevaluate_remote_temp

  # Helper script to calculate the "correct" temperature to use based upon availability
  # and sensor setting.
  - id: reevaluate_remote_temp
    then:
      - lambda: |-
          auto  mode       = id(${hp_id}).mode;
          float backup     = id(rts_backup_sensor).state;
          float primary    = id(rts_primary_sensor).state;
          bool  backup_ok  = !isnan(backup);
          bool  primary_ok = !isnan(primary);
          float result     = NAN;

          ESP_LOGI("main", "Re-evaluating remote temp: backup=%.1f, backup_ok=%d, primary=%.1f, primary_ok=%d, mode=%d", backup, backup_ok, primary, primary_ok, mode);

          if (${rts_average_value}) {
              if (primary_ok && backup_ok) {
                result = ((primary + backup) / 2.0);
              } else if (primary_ok) {
                result = primary;
              } else if (backup_ok) {
                result = backup;
              }
              
          } else {
              if (primary_ok) {
                result = primary;
              } else if (backup_ok) {
                result = backup;
              }
          }

          if (isnan(result)) {
            ESP_LOGW("main", "No valid temperature sensors; remote temp update skipped.");
            id(rts_effective_temp).publish_state(NAN);
          }
          else if (id(rts_effective_temp).state != result) {
            // Publish an update if the temp has changed
            id(rts_effective_temp).publish_state(result);
          }

